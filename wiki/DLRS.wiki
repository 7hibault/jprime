#summary Tutorial for using JPrIME-DLRS.

= JPrIME-DLRS =

== CONTENTS ==
  # [DLRS#INTRODUCTION Introduction]
  # [DLRS#INPUT Input]
  # [DLRS#OUTPUT Output]
  # [DLRS#RUNNING Running]
  # [DLRS#ANALYSIS Analysis]

----
----

== INTRODUCTION ==

DLRS (previously known as GSR and GSRf) is a phylogenetic model for the evolution of a guest tree (_gene family_) inside a host tree (_species tree_). The evolution of the guest tree can be envisioned as occurring in separate phases:
  # The guest tree topology is created by evolving down the host tree by means of duplications and loss events according to a birth-death process. Lineages branch deterministically at speciations.
  # Using the ultrametric times of the guest tree, relaxed branch lengths are obtained by multiplying each branch time with an iid substitution rate according to some distribution.
  # Using the guest tree topology and branch lengths, sequence evolution occurs over the guest tree according to an arbitrary substitution model to produce guest family sequences at the leaves. Possibly, site rate variation occurs according to a gamma distribution.

Hence the name DLRS = duplications, losses, rates & sequence evolution.

The application JPrIME-DLRS corresponding to the model is used for obtaining the unknown guest tree topology and model parameters in light of a known and dated host tree and known sequence data for the leaves. The method relies on Bayesian inference using an MCMC framework. Thus, it will yield a posterior distribution of guest tree topologies and remaining parameters.

*Input:*
  * a file with a dated host tree.
  * a file with a multiple sequence alignment (MSA) of guest tree leaf sequences.
  * a file with a simple map relating the guest tree leaves to host tree leaves.

*Output:*
  * a file with samples drawn from the posterior distribution.
  * a supplementary info file with settings, proposal acceptance ratios, etc.

----
----

== INPUT ==
 
=== Host tree ===
Obtain a dated species tree in Newick format. The divergence times may be specified as branch lengths, e.g.:
{{{
((A:0.4,B:0.4):0.6,C:1.0):0.5;
}}}
Alternatively, one can specify absolute times using special formatting:
{{{
((A[&&PRIME NT=0.0],B[&&PRIME NT=0.0])[&&PRIME NT=0.4],C[&&PRIME NT=0.0])[&&PRIME NT=1.0][&&PRIME TT=0.5];
}}}
The host tree must be ultrametric, with time 0 at the leaves and time >0 at the root, and a "stem" with timespan >0 (in the above example this was set to 0.5). The scale of the dates can be any unit: *they will be rescaled internally prior to running so that the root time is 1.0, and the output will refer to this scaling*, and not the original values. The scale factor is included in the info output file.

A good resource for divergence times is [http://www.timetree.org]. If you cannot find references to reliable divergence times, you will need to date the tree yourself. Typically, this is achieved by obtaining a set of "core" gene families (e.g. monocopy putative orthologs, housekeeping genes, etc.), aligning these, then feeding the concatenated multiple locus sequence alignment (MLSA) into a program which estimates divergence times. For acquiring core genes for microbial datasets [http://www.plosone.org/article/info%3Adoi%2F10.1371%2Fjournal.pone.0024704 this article] may be of help. For dating, consider e.g. [http://beast.bio.ed.ac.uk BEAST], [http://www.biomedcentral.com/1471-2148/8/77 MAP-DP], [http://www.phylobayes.org PhyloBayes] or [http://loco.biosci.arizona.edu/r8s r8s].

=== Multiple sequence alignment and substitution model ===
The multiple sequence alignment (MSA) can be computed with any suitable program (MAFFT, MUSCLE, CLUSTAL, etc.), but should be provided on the FASTA format, e.g. for the example above:
{{{
>a1
MTKKELIKSIAEKNKTSITQTEEFYNSFENAIIKAI
>a2
MTKKELIKSIAEKNKTSITQTEEFYNSFENAIIKAI
>b1
MNKKELIKSIAEVNKTSITQTEEFYNSFENALIKAI
>c1
MNKKELIKSIAEVNKTSITQTEEFYNSFENALIKAI
>c2
MNKKELIKSIAEVNKTSITQTEEFYNSFENALIKAI
}}}
Please consider clearing ambiguous positions from the alignment before feeding it into JPrIME-GSRf. There are many such applications, e.g., [http://trimal.cgenomics.org trimAl], [http://sourceforge.net/projects/probmask/ ZORRO], [http://molevol.cmima.csic.es/castresana/Gblocks.html Gblocks], [http://guidance.tau.ac.il GUIDANCE] and [http://zfmk.de/web/Forschung/Tagungen/2012/201202_GfBS/Workshops/ALISCORE/index.de.html  ALISCORE].

JPrIME-DLRS does not infer substitution model parameters during a run. You may choose from some common built-in models (JTT, JC, etc.), or you may provide your own time-reversible model through a program option. There are programs that help you determining a suitable model, e.g., [http://darwin.uvigo.es/software/prottest.html PROTTEST] and [http://darwin.uvigo.es/software/jmodeltest.html jMODELTEST].

=== Mapping ===
The guest-to-host leaf map is a straightforward tab-delimited file, e.g., for the example above:
{{{
a1   A
a2   A
b1   B
c1   C
c2   C
}}}

----
----

== OUTPUT ==
Output normally consists of two files, e.g.:
  * {{{myoutput.mcmc}}}, containing tab-delimited samples drawn from the posterior distribution.
  * {{{myoutput.info}}}, containing general pre- and post-run information.
The former will look something like:
{{{
N       L         Param1     Param2   Param3
0       1.5e-64   1.0        0.1      0.1
200     2.4e-32   0.56       0.23     0.43
400     1.5e-30   0.51       0.18     0.52
...
}}}

----
----

== RUNNING ==

=== Starting the application===
Typically, you would start JPrIME-DLRS by running e.g.:
{{{
java -cp mypath/jprime-0.0.0.jar -Xms128m -Xmx1024m se/cbb/jprime/apps/dlrs/DLRS [options] <host tree> <msa> <guest-to-host map>
}}}
where the path and version of course refer to your current setup.
Alternatively, you may specify all input in a file thus:
{{{
java -cp mypath/jprime-0.0.0.jar -Xms128m -Xmx1024m se/cbb/jprime/apps/dlrs/DLRS @<parameter file>
}}}
You may want to tune the Java VM to your specific needs (heap size, performance tuning options, etc.). The memory requirements will primarily depend on the size of your gene family, MSA length and substitution model. Tuning a Java VM is otherwise a non-trivial area and is probably not necessary. If you are using an Oracle Java HotSpot VM (which is recommended), these documents may be of assistance: [http://www.oracle.com/technetwork/java/hotspotfaq-138619.html Oracle Java HotSpot VM FAQ] and [http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html Oracle Java HotSpot VM Options].

===Pilot runs===
Before performing your real run, you should make a pilot run to assess the MCMC mixing and change tuning parameters accordingly. The length of a pilot run needs typically not be as long as the final run. Try striving for parameter acceptance ratios of 0.2 - 0.5 (preferably in the lower region). Even so, around 0.1 - 0.7 might do the trick on smaller trees. For the topology, the acceptance ratios will typically be much lower, and cannot really be tuned. The acceptance ratios can be inspected in the info file. For larger trees, consider increasing the weight for how often tree moves are carried out.

===Final runs===
For your final runs, the number of iterations required and a suitable thinning factor will depend on the size of your input. No exact numbers can be provided; you will have to rely on "common sense", and analyses ;-)  You probably want to perform 2 - 4 independent "parallel" MCMC chains to be able to conduct proper analysis.

----
----

== ANALYSIS ==
Consider using [http://cran.r-project.org CRAN R] in general. Several MCMC-tailored analysis softwares exist, among them:
  * [VMCMC JPrIME-VMCMC].
  * The CRAN R package [http://cran.r-project.org/web/packages/coda/index.html CODA].
  * [http://tree.bio.ed.ac.uk/software/tracer/ Tracer].
As in all MCMC inference, you should discard an initial proportion of the samples as burn-in. Convergence statistics may assist you in determining how many. Such measures typically include Gelman-Rubin diagnostics, effective sample size (ESS), potential scale reduction factor (PSRF), sample autocorrelation, and simply manual inspection of the agreement of log-likelihoods and parameter estimates for parallel chains.

----